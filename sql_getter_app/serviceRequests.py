from sys import version
import flask_login
from flask import (Flask,escape, redirect, render_template, request, session, url_for, Blueprint, abort, make_response)
from sqlalchemy.sql.expression import false, true
from crud import getColumnTypes
from auth import login_required
from createTableHtml import tableHtml
from collection import db, production, versionString
from sqlalchemy import text

import json

from tables import item, tablePermissions


bp = Blueprint("serviceRequests", __name__)

@bp.route('/ServiceRequest')
@login_required
def serviceRequest():
    return serviceRequestPull('DEVING')

#gets the table from the database
#@param dName = the name of the table
#       mask = the display name of the table
def serviceRequestPull(mask):
    
    from menuCreation import getMenuForRole

    User = flask_login.current_user
    dName = 'ServiceRequest'
    from sqlCommandClass import sqlCommands

    # get the permissions object for the table
    tablePermissions = User.getPermissionsObject(dName)
    # uncomment these 2 lines if you want to track how long each process takes
    #from collection import profiled
    #with profiled():

    if tablePermissions['canView']:

        keys = [
            ('serviceRequestId',), 
            ('description',),
            ('userIdRequestor',),
            ('userIdTechnician',),
            ('priorityId',), 
            ('statusId',),
            ('estimatedDueDate',),
            ('buildingId',), 
            ('location',), 
            ('serviceTypeId',), 
            ('requestDate',),
            ('contactedDate',),
            ('externalId',),
            ('completedDate',)
            ]
        # start an instance of our tableHtml class (it generates table html and fetches linked elements)
        code = tableHtml(User, dName, 'serviceRequestId')
        code.newHeader(keys)

        #construct a string with the columns seperated by commas
        columns = str()
        for key in keys:
            columns += key[0] + ','
        columns = columns[:-1] # get rid of the last comma

        # start an instance of our sqlCommands class and use it to take the 'filter' object from the javascript
        #   (if ther is one) and turn it into an sql where clause
        where = sqlCommands(dName)
        where.where(request.args.get('filter'))
        
        # construct the actual sql command string
        command = f"SELECT {columns} FROM [{dName}] {where.text}"
        # execute the string with the where parameters
        result = db.engine.execute(text(command), where.insertDict).fetchall()
        # feed the result to the tableHtml class so it can do it's thing
        code.content(result)

        # picks which columns are uneditable
        uneditableList = ['userIdModified']

        # return the html generated by the table.html template (it's a file in the folder templates)
        return render_template('table.html',
            body=code.html, # string - the html for the table
            userN=User.fullName, # string - the users name
            userId=User.tableId, # string - the users Id number
            linkedColData=code.linkedElements(), # object - from the linked data file
            testing='false', # string - testing (should be false here)
            columns=code.columnArray, # list - of the columns
            uneditableColumns=uneditableList, # list - columns that shouldn't be edited
            permissionsObject=tablePermissions, # object - the permissions of the user
            tableName=dName, # string - the name of the table (must be the sql name)
            role=User.roleText, # string - the role for the user, 'Admin', 'Mechanic', etc
            columnTypes=getColumnTypes(dName), # object - the columns with their types
            linkedChildrenExist=True, # boolian - if 'linked' buttons should be added
            mask=mask, # string - the title for the table
            title=f'Cool name: {mask}', # string - the title for the page (the name that appearsw on the tab)
            pageOnLoadFunction='serviceRequestInit()', # the javscript function to run onload of the page
            isAdmin=User.isAdmin,
            production=production,
            menuObject=getMenuForRole(User),
            versionString=versionString
            )
    else:
        # if the user can't view the table return the unauthorized error page
        abort(403)



# link called when a service request is opened and the items are loaded
@bp.route('/serviceRequestItems/<requestId>')
@login_required
def serviceRequestItems(requestId):
    # put the showDeleted in a state we can use (not a string)
    User = flask_login.current_user
    # catch a user who is not logged in
    if (not User.is_authenticated):
        return 'unauthorised, ', 403

    dName = 'RequestItem'
    itemkeys = (('itemId',),('quantity',),('statusId',)) # changes here should also be made to the sql command about 20 lines down
    primaryKey = 'requestItemId'

    #check to see if the user can view the contents of this table
    if User.canView(dName):

        # start an instance of our tablehtml class
        code = tableHtml(User, dName, primaryKey)
        # create the header for the table and include the linked data in the header
        code.newHeader(itemkeys, linkedDataTag=True, columnTypes=getColumnTypes(dName))
        # check to see if we have a valid requestId (if not this is probably blank)
        if requestId.isdigit():
            # sql command
            command = text(f'SELECT {primaryKey}, {itemkeys[0][0]}, {itemkeys[1][0]}, {itemkeys[2][0]}, active FROM [{dName}] WHERE serviceRequestId=:srId;')
            result = db.engine.execute(command, {'srId':str(requestId)}).fetchall()
            # if the result has any rows fill in the table
            if (len(result)>0): code.content(result, true)
            # else display the no rows message
            else: code.noRows('No Items yet')
        
        else:
            # add a no items text
            code.noRows('No Items yet')
        return code.html
    else:
        return 'unauthorized', 403



# link called when a service request is opened and the notes are loaded
@bp.route('/serviceRequestNotes/<requestId>')
@login_required
def serviceRequestNotes(requestId):
    User = flask_login.current_user
    # catch a user who is not logged in
    if (not User.is_authenticated):
        return 'unauthorised, ', 403

    dName = 'RequestNote'
    # CHANGING THE ORDER OF THESE COLUMNS REQUIRES CHANGES TO THE JAVASCRIPT static/serviceRequest/srNotes.js/createInputNewNoteRow()
    sqlKeys = (('note',),('userIdCreator',),('private',)) # changes here should also be made to the sql command about 20 lines down
    primaryKey = 'requestNoteId'

    #check to see if the user can view the contents of this table
    if User.canView(dName):

        # start an instance of our tablehtml class
        code = tableHtml(User, dName, primaryKey)
        # create the header for the table and include the linked data in the header
        code.newHeader(sqlKeys, linkedDataTag=True, columnTypes=getColumnTypes(dName), uneditableList=['userIdCreator'])
        # check to see if we have a valid requestId (if not this is probably blank)
        if requestId.isdigit():
            # sql command
            command = text(f'SELECT {primaryKey}, {sqlKeys[0][0]}, {sqlKeys[1][0]}, {sqlKeys[2][0]}, active FROM [{dName}] WHERE serviceRequestId=:srId;')
            result = db.engine.execute(command, {'srId':str(requestId)}).fetchall()
            # if the result has any rows fill in the table
            if (len(result)>0): code.content(result, true)
            # else display the no rows message
            else: code.noRows('No Notes yet')
        
        else:
            # add a no items text
            code.noRows('No Notes yet')
        return code.html
    else:
        return 'unauthorized', 403


# link called when a service request is opened and the items are loaded
@bp.route('/serviceRequestRequestor/<requestId>')
@login_required
def serviceRequestRequestors(requestId):
    # put the showDeleted in a state we can use (not a string)
    User = flask_login.current_user
    # catch a user who is not logged in
    if (not User.is_authenticated):
        return 'unauthorized, ', 403

    dName = 'Requestor'
    itemkeys = (('firstName',),('lastName',),('email',),('phoneNumber',),('netId',)) # changes here should also be made to the sql command about 20 lines down
    primaryKey = 'requestorId'

    #check to see if the user can view the contents of this table
    if User.canView(dName):

        # start an instance of our tablehtml class
        code = tableHtml(User, dName, primaryKey)
        # create the header for the table and include the linked data in the header
        code.newHeader(itemkeys, linkedDataTag=True, columnTypes=getColumnTypes(dName))
        # check to see if we have a valid requestId (if not this is probably blank)
        if requestId.isdigit():
            # sql command
            command = text(f'''SELECT {primaryKey}, 
                {itemkeys[0][0]}, 
                {itemkeys[1][0]}, 
                {itemkeys[2][0]}, 
                {itemkeys[3][0]}, 
                {itemkeys[4][0]}, 
                active 
                FROM [{dName}] WHERE serviceRequestId=:srId;
            ''')
            result = db.engine.execute(command, {'srId':str(requestId)}).fetchall()
            # if the result has any rows fill in the table
            if (len(result)>0): code.content(result, true)
            # else display the no rows message
            else: code.noRows('No Requestors yet')
        
        else:
            # add a no items text
            code.noRows('No Items yet')
        return code.html
    else:
        return 'unauthorized', 403








@bp.route('/printSingleServiceRequest', methods=['POST'])
@login_required
def printFromHtml():
    import pdfkit
    import datetime
        # get the data, the javascript had to pass it as a form so it could open in a new page
    data = json.loads(request.form['html'])
        # our path to the wkhtmltopdf executable
    path_wkhtmltopdf = r'C:\Program Files\wkhtmltopdf\bin\wkhtmltopdf.exe'
        # configure the pdfkit module
    config = pdfkit.configuration(wkhtmltopdf=path_wkhtmltopdf)
        # get the current time
    currentTime = datetime.datetime.now()
    
    footer = str(currentTime.date())
        # pdf options are found here https://wkhtmltopdf.org/usage/wkhtmltopdf.txt\ these command line flags are 
        # inserted here as a dictionary with initial dashes removed
    options = {
        'grayscale':'',
        'quiet':'',
        'header-right':'[page]/[toPage]',
        'orientation':'Landscape',
        'header-left':'BYU A/C SHOP: CONTROLS',
        'footer-left':footer,
        'footer-font-size':10,
        'footer-font-name':'Ariel'
    }
    # cast our return html as a string
    data = str(data)
    # condition the raw data (html) fro printing
    data = data.replace('textarea', 'p')

    # CSS to be used on the printout, mostly hiding elements we don't want to see
    # and table formating
    import os
    with open(os.getcwd()+'\\sql_getter_app\\static\\css\\serviceRequests\\singlePrint.css', 'r') as file:
        rawCssText = file.read().replace('\n', '')
    finalHtml = f"""
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <style>{rawCssText}
    </style>a

    <div style='singlePrintGrid'>{data}</div>"""
        # create the actual file and store it as a variable
    pdfFile = pdfkit.from_string(finalHtml, False, configuration=config, options=options) 
        # tell the browser to display it as a pdf and set the filename
    response = make_response(pdfFile)
    response.headers['Content-Type'] = 'application/pdf'
    fileNameString = f"_Report_{currentTime.date()}"
    response.headers['Content-Disposition'] = f'inline; filename={fileNameString}.pdf'
    #return response
    return finalHtml