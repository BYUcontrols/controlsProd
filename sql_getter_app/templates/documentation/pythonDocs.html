{% extends "layout.html" %}
{% block title %}
Main Page
{% endblock %}

{% block name %}
{{userN}}
{% endblock %}

{% block role %}
{{role}}
{% endblock %}

{% block loggedIn %}
{{loggedIn}}
{% endblock %}

{% block content %}
<!-- the raw block makes it so that no jinja template code will be executed -->
{% raw %}
<a name="top"></a>
<pre style='background-color: white; padding: 10px;'>

Here we will talk about how the server side elements of our application work. 
If you have questions about the client side stuff look at the JavaScript Manual

To create the requirements document use the command: pip freeze > requirements.txt

The server is written in python and functions using the following modules:
    flask - http request handling - https://flask.palletsprojects.com/en/1.1.x/
    modWSGI - for interface between the flask application and the Apache server - https://modwsgi.readthedocs.io/en/master/ and https://flask.palletsprojects.com/en/1.1.x/deploying/mod_wsgi/
    sqlAlchemy - to access the database - https://www.sqlalchemy.org/

Our code is (should be at least) very well commented and will be easy to follow but to get you started
here basic overviews for the processes of our app. If you want any details go read the comments 
next to the actual code!

Table of Contents:
<a href='#http'>Handling an http request</a>
<a href='#serv'>Serving html</a>
<a href='#data'>Talking to the database</a>
<a href='#apa'>Flask talking to Apache</a>
<a href='#usr'>User Authentication</a>
<a href='#cas'>Byu CAS (central authentication system)</a>
<a href='#men'>Loading Menus</a>
<a href='#tbl'>Displaying tables</a>
<a href='#cth'>Create Table Html</a>
<a href='#edi'>Editing, creating new rows, Auditing, and printing</a>
<a href='#'></a>


<a name='http'></a><a href='#top'>Top of page</a>
Handling an http request
    1. A user sends a request for the home page '/home'
    2. Flask looks for a function with the wrapper (the thing with the @ before functions) @bp.route('/home') before it
    3. Flask finds that function in tables.py and then runs it home()


<a name='serv'></a><a href='#top'>Top of page</a>
Serving html
    1. functions with the @bp.route() wrapper should return strings
    2. full page requests (browser requests) use render_template() to generate the html
    3. render_template()'s first argument is a string that points to a file_
        in the 'templates' folder that contains an html template (rendered using the JINJA module, https://jinja.palletsprojects.com/en/2.11.x/) 
    4. other arguments are values to pass to the templates. (in the form of a key and a value, key='value')
    5. the JINJA template engine then parses the template file and the arguments provided
        to return an html string that is passed ot the user's browser.


<a name='data'></a><a href='#top'>Top of page</a>
Talking to the database
    1. in __init__.py when the server starts it starts a connection with the database using
        the sqlAlchemy's .init_app(app)
    2. Connection configuration is located in collection.py
    3. Every python file that will access the database imports the db object from collections.py
    4. We can then run sql commands using db.execute(text('sql command text'), parameters)
    5. text() parses strings into sql friendly commands (including parameter markers)
    6. parameter markers are how we pass data safely to the sql command (format -> :nameOfParameter)
    7. Then in .execute() the second argument is a dictionary (https://docs.python.org/3/tutorial/datastructures.html)
        with the parameter names and their values (eg {'nameOfParameter':value})
    8. .execute() returns a ResultProxy object that contains the requested data (https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.ResultProxy)
    NOTE: we usually call .fetchall() on our ResultProxies because it turns them into a much easier to deal with
        list of RowProxies (https://docs.python.org/3/tutorial/datastructures.html AND https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.RowProxy)


<a name='apa'></a><a href='#top'>Top of page</a>        
Flask talking to Apache
    See the controls-app/docs/APACHE_CONFIG.txt for information on how to set up an apache server

    Apache talks to flask through a module (python and apache) called mod-wsgi. We import it through python's pip tool
    and that module contains the apache module. Here is about how that process works.

    1. In the Apache Apache/conf/controls.conf script we tell apache what to do when a user tries to access our site. There we
        load the apache mod-wsgi module and pass it our appLoader.wsgi script. (located in the same folder as sql_getter_app)
    2. appLoader.wsgi starts the virtual environment and then calls sql_getter_app/__init__.py/create_app()
    3. create_app() loads our application and starts everything (Flask, login_manager, sqlAlchemy, etc.)
    4. The mod_wsgi in apache then serves our application all the requests from the users.


<a name='usr'></a><a href='#top'>Top of page</a>
User Authentication
    1. A function has the @login_required wrapper (defined in auth.py)
    2. @login_required asks the login_manager object (defined in collection.py) if the user is logged in
    3. If the user is not logged in we send them a page that redirects them to the Byu CAS login api 
        (defined in auth.py at loginPage())
    4. If the user is logged in then @login_manager (the gatekeeper of sorts) lets the page function run
    5. Inside any python function the code can reference flask_login.current_user to get more data about the user
        - flask_login.current_user is an instance of our user class (user_class.py)
        - it is created at '/login'
        - it has functions that tell you all about the user (what tables they can access, name, role, etc.)
    
    Further information about what permissions a user has for a table are obtained by...

        1. When a user is logged in (see the next section) user.getData() is called which grabs the roleId for the
            user. This represents the role for the table
        2. The Server tries to access a permission level through: 
            user.canView(), user.canEdit(), user.canAdd(), user.canDelete(), 
            user.canUnDelete(), user.canAudit(), or user.getPermissionsObject()
        3. Those functions get the permission list from the TablePermissions table 
            (or the DEFAULT if there is no row for that table) for the action wanted.
        4. They then parse that permission list (user.parseTablePermissionsResult()) and see if the Users roleId is
            on that list granting them access or not.
        5. Admins are always allowed permission, regardless of what the tablePermissions table says


<a name='cas'></a><a href='#top'>Top of page</a>
Byu CAS (central authentication system)
    We use the byu login api to login our users (using their byu account) instead of creating our own login system
    because #1, We don't want everyone ending up using the same account #2, everyone already has a byu account and #3,
    do you really need another password to remember? 
    First we will go over how to set up the site with the api.
    
        1. Go to https://api.byu.edu/store/ and login to with your byu credentials
        2. Go to the 'My Applications' tab
        3. Create your new application with the callback url being https://###site url###/redirect_from_auth
        4. Go to the 'My Subscriptions' tab and from the dropdown select your new application
        5. Click 'generate keys' in the production box
        6. copy the Key and Secret into sql-getter-app/collection.py...  

            oauthKey = '### Consumer Key ###'
            oauthSecret = '### Consumer Secret ###'
            oauthRedirect = '### The Callback url you choose in step 3 ###'

    Now we will go over how this works

        1. When a user who has not logged in tries to access a page with the @login_required flag the flask login
            manager return the loginPage() view defined in sql_getter_app/auth.py
        2. This view saves the url they were trying to access in the browser localStorage and...
        3. Redirects the user to the byu login page with the Consumer Key in the url. When the user
            logs into byu the byu login api sends them to the Callback Url we set up earlier with a 'code' argument
        4. The /redirect_from_auth endpoint on our server (sql_getter_app/auth.py/redirect_from_auth()) takes out the
            code, creates a new instance of our user_session class (sql_getter_app/user_class.py), sets all the variables for
            the user that we need (table permissions, etc.) using the user_session.setFromToken(code), then passes the logged
            in user_session to the login_manager.
        5. user_session.setFromToken() takes the code and sends a request (from our server) to the https://api.byu.edu/token
            api with our credentials (key and secret) and the code for the user. The api sends back the byu id of the user.
        6. That byuId is then processed (user_session.getData()) to get the table access level, role, and name for this user.
        7. Lastly /redirect_from_auth returns a page to the user that redirects them to the url saved in step 2



<a name='men'></a><a href='#top'>Top of page</a>
Loading Menus
    Menus displayed to the user cannot be just plain typed out html because different users will not have access
    to all the menus. So...

    1. All the menu data is stored in menuCreation.py/rawMenu
    2. When the server is start up init.py runs menuCreation.py/createMenus() which loops through the rawMenu and adds and fills the 'viewingLevel'
        argument for each options with the tables viewingLevel from the TablePermissions sql table
    3. Then each time a page is loaded the menuCreation.py/getMenuForRole() function is called and returns the rawMenu, just without the options
        that the user does not have permission to view.
    4. The new rawMenu is passed to the jinja html template which is looped through using the template function in templates/menu_options.html
        to create the html menus that are displayed to the user.


<a name='tbl'></a><a href='#top'>Top of page</a>
Displaying tables
    1. the urls for the tables are their sql tableName (eg '/Building' for the buildings table)
    2. All the @bp.route()'s for the tables are in tables.py
    3. Those table functions call the function pull() from crud.py
    4. pull() returns talks to the database 
        and generates html for the table using the tableHtml class (createTableHtml.py)

<a name='cth'></a><a href='#top'>Top of page</a>
Creating table Html
    Any time the user requests a table (audits, linked tables, just plain tables, etc.)
    We execute a sql query to retrieve the data and then feed that data into the createTableHtml class
    to turn the resultProxy objects returned from the server into html tables that work with
    the client side javascript. Here are the members of that class ( located in createTableHtml.py)

        constructor - 
            The constructor saves the arguments to the class (data about the table needed by the class)

        newHeader - 
            Assembles the header (&lt;th>) string and if the linkedDataTag is true then also includes
            data about the table in there for the javascript as html tags

        content - 
            Takes the resultProxy and adds to the table html string created in hewHeader the rest of the
            data in the table

        linkedElements - 
            Looks through the list of linked columns in linkedColumns.py and the current keys to look
            to see if we have any linked columns. If we do it calls self.getLinkedColumn() on that column
            and returns all the day

        getLinkedColumn - 
            queries the database for the linked data (name column and id column) for the linked database
            and returns it


<a name='edi'></a><a href='#top'>Top of page</a>
Editing, creating new rows, Auditing, and printing
    1. The user performs an action that causes the javascript (the code that runs on the user's browser)
        to send a http request to the server ( for instance to the '/print' url in crud.py)
    2. The functions associated with those urls do something then return a string to the javascript.
</pre>
{% endraw %}
{% endblock %}